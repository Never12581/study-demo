## Redis复制实现



### 名词释义

- 同步：在redis中，slaveof命令或者设置slaveof选项，可以让一个服务器复制另一个服务器，复制以及保持两台服务器内容相同的动作称为复制
- 主服务器（master）：我们称被复制的服务器为主服务器。
- 从服务器（slaveof）：对主服务器进行复制的服务器为从服务器。
- sync：同步命令
- bgsave：后台异步保存当前数据库数据到磁盘
- rdb文件：内存快照。即当前redis内存中保存的值以二进制文件保存在硬盘上。
- psync：新版同步命令（包含：完整重同步与部分重同步）



### 2.8版本之前复制功能的实现

#### redis的复制分为同步(sync)与命令传播(command propagate)两个操作

- 同步：

  当客户端向<font color='yellow'>从</font>服务器发送slaveof命令，要求从服务器复制主服务器时，从服务器需要先执行同步，即向主服务器发送sync命令，以下是sync命令的执行步骤

  1. 从服务器向主服务器发送sync命令
  2. 收到sync命令的主服务器执行bgsave命令，在后台生成一个RDB文件，并使用一个<font color='red'>缓冲区</font>记录从现在开始执行的所有写命令
  3. 当主服务器bgsave执行完毕后，主服务器会将生成的RDB文件发送给从服务器，从服务器接收并载入该RDB文件，将自己数据库状态更新至主服务器执行bgsave命令时的状态
  4. 主服务器将记录在<font color='red'>缓冲区</font>里所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器当前所处状态

- 命令传播：

  当同步操作执行完毕后，主从服务器二者数据库状态达到一致，但当前种一致状态并非一成不变，当主服务器执行客户端发送的写命令时，主服务器数据库可能会被修改而导致主从服务器二者状态不一致。故需要命令传播：即将主服务器的写命令，发送给从服务器，当从服务器执行该条命令后，二者状态重回一致。（与同步中的4相似）

> ps: 有主服务器M，从服务器S，
>
> 客户端对M 进行 setex a 10 "我是A" 这条命令，同步给了S
>
> 因redis使用“惰性删除策略”与“定期删除策略”的组合，故M在过期的第一时间可能未删除a
>
> 此时，客户端对S进行了 get a 命令，依然能得到 值 “我是A” 
>
> 即：从服务器不会对过期的健进行删除，只执行主服务器命令传播过来的写命令（为保证数据一致性）

#### 2.8版本之前复制功能的缺陷

从服务器对主服务器进行复制，可以分为以下两种情况：

- 初次复制：即当前从服务器内存为空 或者 要复制的主服务器与上次复制的主服务器不同
- 断线后重新复制：处于命令传播阶段的主服务器因网络原因中断了复制，在网络恢复后重新连接上了主服务器，并继续复制主服务器

在初次复制的时候旧版能够很好的完成任务，也不会造成资源浪费。但是在断线后重新复制，旧版复制也能完成任务，但是造成的资源浪费比较严重！举例如下：

> T0 ~ T1 主从服务器复制完成
>
> T1 ~ T2 通过命令传播主从服务器状态保持一致
>
> T3 因网络原因断开连接
>
> T4 此时网络恢复，从服务器重新开始同步 ， 从服务器发送sync命令，主服务器生成从T0 ~ T4的RDB文件...

其实 从服务器中 存在T0 ~ T2 时间段的数据，在T4重新同步的时候，仅仅需要T3 ~ T4中的写命令即可，sync命令又极为消耗资源，故此为旧版复制的缺陷。

> ps: sync极为消耗资源！
>
> 1. 主服务器执行bgsave命令时，消耗大量CPU，内存及硬盘IO
> 2. 主服务器发送RDB文件时需要大量网络资源（带宽和流量），会对主服务器命令响应造成影响
> 3. 从服务在接收到RDB文件时，会阻塞操作内存的线程，从而无法对其他命令进行响应



### 2.8版本之后（含 ）的复制

为解决2.8版本之前，断线重新同步的低效问题，2.8版本开始使用psync命令代替sync命令执行复制时的同步操作。

psync命令具有**完整重同步(full resynchronization)** 和**部分重同步(partial resynchronization)**两种模式：

- 完整重同步 用于初次复制 时的情况，执行步骤与sync命令基本一致
- 部分重同步 用于处理断线后重新复制的情况，如果条件允许，主服务器将断开连接期间执行的写命令发送给从服务器，从服务器接收并执行这些写命令，将从服务器状态更新至与主服务器一致



#### 部分重同步的实现

主要由以下三个部分构成：

- 主服务器的复制偏移量（replication offset）与从服务器的复制偏移量
- 主服务器的复制积压缓冲区（replication backlog）
- 服务器的运行ID（run ID）

##### 复制偏移量

主从服务器双方各自维护了一个复制偏移量：

- 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N
- 从服务器每次接收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量加上N

> e.g. 主服务器M 与 三台从服务器 S1，S2，S3。此时他们的复制偏移量都为12138。此时，客户端对M进行了写操作，然后M向S1，S2，S3分别传播了22字节的数据，此时M的复制偏移量为12160，S1，S2，S3三台从服务器的复制偏移量也为12160。

通过对比复制偏移量，可以很容易的知道主从服务器是否处于一致状态：

- 若主从服务器处于一致状态，则复制偏移量相等
- 若复制偏移量不相等，则主从服务器并未处于一致状态

> e.g. 主服务器M与三台从服务器S1，S2，S3。此时他们的复制偏移量都是12138。此时，客户端对M进行了写操作，然后M向S1，S2，S3分别传播了22字节的数据，然后这时候S1从服务器出现网络抖动，M传播的数据仅S2与S3收到了，此时M与S2，S3的复制偏移量为12160，而S1的复制偏移量仍为12138。则M与S2，S3为一致状态，与S1为不一致状态。具体将执行完成重同步还是部分重同步，请往下看

##### 复制积压缓冲区

复制积压缓冲区是由主服务器（master）维护的一个固定长度（fix-size）先进先出（FIFO）队列，默认大小为1MB。

> 与普通的FIFO队列一致，新元素从一边进入队列，从另一边弹出。
>
> 不同点在于，该队列是定长的。故当，入队元素大于队列长度的时候，最先入队的元素会被弹出，而新元素会被放入队列。

当主服务器进行命令传播的时候，它不仅会将写命令发送给所有服务器，还会将写命令入队到复制积压缓冲区中。因此，主服务器的复制积压缓冲区中会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中每个字节记录相应的复制偏移量，如下图：

| 偏移量 | ···  | 12139 | 12140 | 12141 | 12142 | 12143 | 12144 | 12145 | 12146 | ···  |
| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ---- |
| 字节值 | ···  | '*'   | 2     | '\r'  | '\n'  | 's'   | 'e'   | 't'   | 'a'   | ···  |

当从服务器重新连接上主服务器后，从服务器会通过psync命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行和中同步操作：

- 如果offset偏移量之后的数据（即offset+1）的数据仍存在于复制积压缓冲区中，那么主服务器将对从服务器执行部分同步操作
- 相反，offset+1的数据不存在于复制积压缓冲区中，则主服务器将对从服务器执行完整重同步操作。

> e.g. 主服务器M与三台从服务器S1，S2，S3。此时他们的复制偏移量都是12138。此时，客户端对M进行了写操作，然后M向S1，S2，S3分别传播了22字节的数据，然后这时候S1从服务器出现网络抖动，M传播的数据仅S2与S3收到了，此时M与S2，S3的复制偏移量为12160，而S1的复制偏移量仍为12138。则M与S2，S3为一致状态，与S1为不一致状态。
>
> - S1重新连接M，并向M发送psync命令，报告自己的复制偏移量为12138
> - M接收到psync命令以及偏移量12138后，检查该偏移量是否存在于复制积压缓冲区，若存在则以部分重同步，若不存在则以完整重同步形式

> ps: 复制积压缓冲区大小可以调整！
>
> redis的默认值为1MB，但是主服务器需要执行大量写命令，或者断线重连时间过长，导致每次重练都是完全重同步则失去了psync命令的意义。
>
> 复制积压缓冲区的最小大小可根据公式：second * write_size_per_second 来估算
>
> 一般设置为 ： 2 * second * write_size_per_second
>
> 其值修改，参考配置文件中repl-backlog-size说明

##### 服务器运行ID（run ID）

除了复制偏移量与复制积压缓冲区以外，实现部分重同步还需要服务器运行ID

- 每个redis服务器，不论主从，都会有自己的运行ID
- 运行ID在服务启动时自动生成，由40个随机组成的十六进制字符组成

当从服务器初次对主服务器进行复制的时候，主服务器会将自己的runID传送给从服务器，从服务器会将该runID进行保存。当从服务器重新连接上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的runID：

- 若从服务器保存的runID与主服务器的runID相同，则可以进行部分重同步操作
- 否则，将执行完整重同步

#### psync命令实现

```flow
st=>start: 开始
e=>end: 结束
op=>operation: 从服务器接收到客户端发来的slaveof命令
cond=>condition: 这是从服务器第一次进行复制？
isFirst=>operation: 向主服务器发送 psync ? -1 
notFirst=>operation: 向主服务器发送 psync <runid> <offset>
masterReturnContinue=>condition: 主服务器返回 +CONTINUE
partReSync=>operation: 执行部分重同步
fullReSync=>operation: 主服务器返回 +FULLRESYNC <runid> <offset> 执行完整重同步

st->op->cond
cond(no)->notFirst->masterReturnContinue
masterReturnContinue(yes)->partReSync->e
masterReturnContinue(no)->fullReSync->e

cond(yes)->isFirst->fullReSync->e
```



