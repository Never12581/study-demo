## Redis复制实现

[toc]

### 名词释义

- 同步：在redis中，slaveof命令或者设置slaveof选项，可以让一个服务器复制另一个服务器，复制以及保持两台服务器内容相同的动作称为复制
- 主服务器（master）：我们称被复制的服务器为主服务器。
- 从服务器（slaveof）：对主服务器进行复制的服务器为从服务器。
- sync：同步命令
- bgsave：后台异步保存当前数据库数据到磁盘
- rdb文件：内存快照。即当前redis内存中保存的值以二进制文件保存在硬盘上。
- psync：新版同步命令（包含：完整重同步与部分重同步）

----

### 2.8版本之前复制功能的实现

#### redis的复制分为同步(sync)与命令传播(command propagate)两个操作

- 同步：

  当客户端向<font color='#358462'>从</font>服务器发送slaveof命令，要求从服务器复制主服务器时，从服务器需要先执行同步，即向主服务器发送sync命令，以下是sync命令的执行步骤

  1. 从服务器向主服务器发送sync命令
  2. 收到sync命令的主服务器执行bgsave命令，在后台生成一个RDB文件，并使用一个<font color='red'>缓冲区</font>记录从现在开始执行的所有写命令
  3. 当主服务器bgsave执行完毕后，主服务器会将生成的RDB文件发送给从服务器，从服务器接收并载入该RDB文件，将自己数据库状态更新至主服务器执行bgsave命令时的状态
  4. 主服务器将记录在<font color='red'>缓冲区</font>里所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器当前所处状态

- 命令传播：

  当同步操作执行完毕后，主从服务器二者数据库状态达到一致，但当前种一致状态并非一成不变，当主服务器执行客户端发送的写命令时，主服务器数据库可能会被修改而导致主从服务器二者状态不一致。故需要命令传播：即将主服务器的写命令，发送给从服务器，当从服务器执行该条命令后，二者状态重回一致。（与同步中的4相似）

> ps: 有主服务器M，从服务器S，
>
> 客户端对M 进行 setex a 10 "我是A" 这条命令，同步给了S
>
> 因redis使用“惰性删除策略”与“定期删除策略”的组合，故M在过期的第一时间可能未删除a
>
> 此时，客户端对S进行了 get a 命令，依然能得到 值 “我是A” 
>
> 即：从服务器不会对过期的健进行删除，只执行主服务器命令传播过来的写命令（为保证数据一致性）

#### 2.8版本之前复制功能的缺陷

从服务器对主服务器进行复制，可以分为以下两种情况：

- 初次复制：即当前从服务器内存为空 或者 要复制的主服务器与上次复制的主服务器不同
- 断线后重新复制：处于命令传播阶段的主服务器因网络原因中断了复制，在网络恢复后重新连接上了主服务器，并继续复制主服务器

在初次复制的时候旧版能够很好的完成任务，也不会造成资源浪费。但是在断线后重新复制，旧版复制也能完成任务，但是造成的资源浪费比较严重！举例如下：

> T0 ~ T1 主从服务器复制完成
>
> T1 ~ T2 通过命令传播主从服务器状态保持一致
>
> T3 因网络原因断开连接
>
> T4 此时网络恢复，从服务器重新开始同步 ， 从服务器发送sync命令，主服务器生成从T0 ~ T4的RDB文件...

其实 从服务器中 存在T0 ~ T2 时间段的数据，在T4重新同步的时候，仅仅需要T3 ~ T4中的写命令即可，sync命令又极为消耗资源，故此为旧版复制的缺陷。

> ps: sync极为消耗资源！
>
> 1. 主服务器执行bgsave命令时，消耗大量CPU，内存及硬盘IO
> 2. 主服务器发送RDB文件时需要大量网络资源（带宽和流量），会对主服务器命令响应造成影响
> 3. 从服务在接收到RDB文件时，会阻塞操作内存的线程，从而无法对其他命令进行响应

----


### 2.8版本之后（含 ）的复制

为解决2.8版本之前，断线重新同步的低效问题，2.8版本开始使用psync命令代替sync命令执行复制时的同步操作。

psync命令具有**完整重同步(full resynchronization)** 和**部分重同步(partial resynchronization)**两种模式：

- 完整重同步 用于初次复制 时的情况，执行步骤与sync命令基本一致
- 部分重同步 用于处理断线后重新复制的情况，如果条件允许，主服务器将断开连接期间执行的写命令发送给从服务器，从服务器接收并执行这些写命令，将从服务器状态更新至与主服务器一致



#### 部分重同步的实现

主要由以下三个部分构成：

- 主服务器的复制偏移量（replication offset）与从服务器的复制偏移量
- 主服务器的复制积压缓冲区（replication backlog）
- 服务器的运行ID（run ID）

##### 复制偏移量

主从服务器双方各自维护了一个复制偏移量：

- 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N
- 从服务器每次接收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量加上N

> e.g. 主服务器M 与 三台从服务器 S1，S2，S3。此时他们的复制偏移量都为12138。此时，客户端对M进行了写操作，然后M向S1，S2，S3分别传播了22字节的数据，此时M的复制偏移量为12160，S1，S2，S3三台从服务器的复制偏移量也为12160。

通过对比复制偏移量，可以很容易的知道主从服务器是否处于一致状态：

- 若主从服务器处于一致状态，则复制偏移量相等
- 若复制偏移量不相等，则主从服务器并未处于一致状态

> e.g. 主服务器M与三台从服务器S1，S2，S3。此时他们的复制偏移量都是12138。此时，客户端对M进行了写操作，然后M向S1，S2，S3分别传播了22字节的数据，然后这时候S1从服务器出现网络抖动，M传播的数据仅S2与S3收到了，此时M与S2，S3的复制偏移量为12160，而S1的复制偏移量仍为12138。则M与S2，S3为一致状态，与S1为不一致状态。具体将执行完成重同步还是部分重同步，请往下看

##### 复制积压缓冲区

复制积压缓冲区是由主服务器（master）维护的一个固定长度（fix-size）先进先出（FIFO）队列，默认大小为1MB。

> 与普通的FIFO队列一致，新元素从一边进入队列，从另一边弹出。
>
> 不同点在于，该队列是定长的。故当，入队元素大于队列长度的时候，最先入队的元素会被弹出，而新元素会被放入队列。

当主服务器进行命令传播的时候，它不仅会将写命令发送给所有服务器，还会将写命令入队到复制积压缓冲区中。因此，主服务器的复制积压缓冲区中会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中每个字节记录相应的复制偏移量，如下图：

| 偏移量 | ···  | 12139 | 12140 | 12141 | 12142 | 12143 | 12144 | 12145 | 12146 | ···  |
| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ---- |
| 字节值 | ···  | '*'   | 2     | '\r'  | '\n'  | 's'   | 'e'   | 't'   | 'a'   | ···  |

当从服务器重新连接上主服务器后，从服务器会通过psync命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：

- 如果offset偏移量之后的数据（即offset+1）的数据仍存在于复制积压缓冲区中，那么主服务器将对从服务器执行部分同步操作
- 相反，offset+1的数据不存在于复制积压缓冲区中，则主服务器将对从服务器执行完整重同步操作。

> e.g. 主服务器M与三台从服务器S1，S2，S3。此时他们的复制偏移量都是12138。此时，客户端对M进行了写操作，然后M向S1，S2，S3分别传播了22字节的数据，然后这时候S1从服务器出现网络抖动，M传播的数据仅S2与S3收到了，此时M与S2，S3的复制偏移量为12160，而S1的复制偏移量仍为12138。则M与S2，S3为一致状态，与S1为不一致状态。
>
> - S1重新连接M，并向M发送psync命令，报告自己的复制偏移量为12138
> - M接收到psync命令以及偏移量12138后，检查该偏移量是否存在于复制积压缓冲区，若存在则以部分重同步，若不存在则以完整重同步形式

> ps: 复制积压缓冲区大小可以调整！
>
> redis的默认值为1MB，但是主服务器需要执行大量写命令，或者断线重连时间过长，导致每次重练都是完全重同步则失去了psync命令的意义。
>
> 复制积压缓冲区的最小大小可根据公式：second * write_size_per_second 来估算
>
> 一般设置为 ： 2 * second * write_size_per_second
>
> 其值修改，参考配置文件中repl-backlog-size说明

##### 服务器运行ID（run ID）

除了复制偏移量与复制积压缓冲区以外，实现部分重同步还需要服务器运行ID

- 每个redis服务器，不论主从，都会有自己的运行ID
- 运行ID在服务启动时自动生成，由40个随机组成的十六进制字符组成

当从服务器初次对主服务器进行复制的时候，主服务器会将自己的runID传送给从服务器，从服务器会将该runID进行保存。当从服务器重新连接上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的runID：

- 若从服务器保存的runID与主服务器的runID相同，则可以进行部分重同步操作
- 否则，将执行完整重同步

#### psync命令实现

![psync命令实现流程图](https://github.com//Never12581/study-demo/blob/master/other-file/picture/%E5%A4%8D%E5%88%B6-psync%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg?raw=true)

```flow
st=>start: 开始
e=>end: 结束
op=>operation: 从服务器接收到客户端
发来的slaveof命令
cond=>condition: 这是从服务器
第一次进行复制？
isFirst=>operation: 向主服务器发送 psync ? -1 
notFirst=>operation: 向主服务器发送 psync <runid> <offset>
masterReturnContinue=>condition: 主服务器返回 
+CONTINUE
partReSync=>operation: 执行部分重同步
fullReSync=>operation: 主服务器返回 +FULLRESYNC 
<runid> <offset> 执行完整重同步

st->op->cond
cond(no)->notFirst->masterReturnContinue
masterReturnContinue(yes)->partReSync->e
masterReturnContinue(no)->fullReSync->e

cond(yes)->isFirst->fullReSync->e
```



----

### 复制的实现

#### 步骤一：设置主服务器的地址和端口

当客户端向从服务器发送 

> slaveof 127.0.0.1 6379

从服务器会将给定主服务器的ip与port保存到从服务器状态的masterhost属性和masterport属性；

即 masterhost=127.0.0.1;  masterport= 6379;

redisServer数据结构如下：

```c
struct redisServer {
  // ...
  char *masterhost ;  // 主服务器ip
  int masterport ; 		// 主服务器port
  // ...
}
```

slaveof命令是一个异步命令，在完成两个属性的赋值后，从服务器向客户端返回OK，表示复制指令已被接收，而实际的复制工作将在OK返回之后真正开始执行。

#### 步骤二：简历套接字连接

从服务器在返回OK之后，根据所设置的masterhost与masterport，创建连向主服务器的套接字连接。如果从服务器创建的套接字能成功连接（connect）到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制写工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令。

主服务器在接受（accept）从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作一个连接到主服务器的客户端。

#### 步骤三：发送ping命令

从服务器成为主服务器的客户端后，第一件事情是发送一个ping命令到主服务器。这个ping命令有两个作用：

- 虽然已经建立了套接字连接，但是双方并未使用该套接字进行过任何通信，通过发送ping命令可以检查套接字的读写状态是否正常
- 因为复制工作接下来的步骤都需要主服务器能够正常处理命令请求的状态下才能进行，所以通过发送ping命令可以检查主服务器能够正常处理命令请求

从服务器发送ping命令后，将遇到以下三种情况之一：

- 如果主服务器向从服务器返回了一个命令回复，但是从服务器却不能在规定的时限（timeout）内读取出命令回复的内容，那么表示主从服务器之间网络连接状态不稳定，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建向主服务器的套接字。
- 如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建连向主服务器的套接字。

> e.g. 如果主服务器正在处理一个超时运行的脚本，那么当从服务器向主服务器发送ping命令时，从服务器将收到主服务器返回 “BUSY Redisis busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.” 的错误

- 如果从服务器读取到“pong”回复，那么表示主从服务器之间的网络连接状态正常，并且主服务器能正常处理从服务器（客户端）发送的命令请求。这种情况下可以执行复制的下个步骤

![ping命令实现流程图](https://github.com/Never12581/study-demo/blob/master/other-file/picture/%E5%A4%8D%E5%88%B6-%E5%8F%91%E9%80%81ping%E5%91%BD%E4%BB%A4%E6%B5%81%E7%A8%8B.jpg?raw=true)

#### 步骤四：身份验证

从服务器在收到主服务器返回的“pong”回复之后，下一步要做的就是决定是否进行身份验证：

- 如果从服务器设置了masterauth选项，那么进行身份验证
- 如果未设置，则不进行身份验证

```c
struct redisServer {
  // ...
  char *masterhost ;  // 主服务器ip
  int masterport ; 		// 主服务器port
  char *masterauth;   // 身份校验的密码 
  // ...
}
```

在需要进行身份验证的情况下，从服务器将向主服务器发送一条AUTH命令，命令的参数为从服务器masterauth选项的值。

从服务器在身份验证阶段可能会遇到以下几种情况：

- 如果主服务器没有设置requirepass选项，且从服务器没有设置masterauth，则继续复制工作
- 如果从服务器通过auth命令发送的密码与主服务器requirepass选项所设置的密码相同，那么主服务器将继续复制工作，不然主服务器返回“invalid passwod” 错误
- 如果主服务器设置了requirepass选项，而从服务器没有设置masterauth选项，那么主服务器将返回一个noauth错误。
- 如果主服务器没有设置requirepass选项，而从服务器设置了masterauth选项，那么主服务器将返回一个“no password is set ”错误

所有的错误情况都会令从服务器中止当前的复制工作，并从创建套接字开始重新执行复制，知道身份验证通过，或者从服务器放弃执行复制为止。

![身份验证实现流程图](https://github.com/Never12581/study-demo/blob/master/other-file/picture/%E5%A4%8D%E5%88%B6-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.jpg?raw=true)

#### 步骤五：发送端口信息

在身份验证之后，从服务器将执行命令 replconf listening-port <port>  ，向主服务器发送从服务器的监听端口号。主服务器在接收到这个命令之后，会将端口号记录在从服务器从服务器所对应的客户端的slave_listening_port属性中

```c
struct redisServer {
  // ...
  char *masterhost ;  // 主服务器ip
  int masterport ; 		// 主服务器port
  char *masterauth;   // 身份校验的密码 
  list *clients;      // 活跃的客户端
  // ...
}

typedef struct client {
  // ...
  int slave_listening_port; // 从服务器监听端口号
  // ...
} client ;

```

目前来看，该值为一的作用就在于主服务器执行info replication命令时打印出从服务器的端口号

#### 步骤六：同步

即，从服务器向主服务器发送psync命令，执行同步操作。

> ps:在执行该步骤之后主服务器也会成为从服务器客户端。
>
> 完整重同步，从服务器在读取RDB文件后，主服务器缓冲区中的写命令发送给从服务器
>
> 部分重同步，向从服务器发送复制积压缓冲区中写命令
>
> 故主服务器也是从服务器的客户端

#### 步骤七：命令传播

即主服务器将自己执行的写命令发送给从服务器。

----

### 心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：

> replconf ack <replication_offset>

其中replication_offset是从服务器当前的复制偏移量。

发送该命令对于著丛服务器有三个作用：

- 检测主服务器的网络连接状态
- 辅助实现min-slaves选项
- 检测命令丢失

#### 检测主从服务器的网络连接状态

主从服务器通过发送和接收replconf ack命令来检查两者间网络连接是否正常：如果主服务器超过一秒没有接收到从服务器发送的该命令，则主服务器就知道主从服务器之间的连接出现了问题。

用户可以在客户端输入：info replication 命令来列出从服务器最后一次发送 replconf ack命令的时间（在lag一栏）。

#### 辅助实现min-slaves配置

redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。

> ps: 如果我们向主服务器提供了以下设置
>
> min-slaves-max-lag 10 
>
> min-slaves-to-write 3
>
> 那么从服务器少于3个，或者三个从服务器的延迟（即lag）的值都大于或等于10秒，主服务器将拒绝执行写命令，这里的lag就是info replication 命令能查看到的lag

#### 检测命令丢失

如果因为网络故障，主服务器传播给从服务器的写命令，在半路丢失，那么当从服务器向主服务器发送 replconf ack命令时，主服务器会发觉从服务器当前的复制偏移量小于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里找到从服务器缺少的数据，并将数据重新发送。



### 参考资料

《Redis设计与实现》黄健宏 机械工业出版社



