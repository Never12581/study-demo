# 线程安全

## Java语言中的线程安全

java语言中各种操作共享数据氛围以下5类：不可变、绝对线程安全，相对线程安全，线程兼容，线程对立

- 不可变：final修饰
- 绝对线程安全：调用者不需要其他额外的同步措施
- 相对线程安全：
- 线程兼容
- 线程对立：如Thread的suspend（）和resume（）方法，两个线程同时持有一个线程对象，一个尝试中断，一个尝试恢复，有造成死锁风险

### 线程安全的实现办法

- 互斥同步（阻塞同步） 即synchronized关键字，J.U.C包中的重入锁ReentrantLock 
- 非阻塞同步 即CAS：变量的内存地址V，旧值的预期值A，新值B，当前仅当V地址的值符合预期为A时，处理器用新值B更新V的值，否则不更新，且该过程是一个原子性的操作
- 无同步方案 即不涉及共享数据，不必同步

## 锁

### 自旋锁与自适应自旋锁

互斥锁对性能影响最大的事阻塞的实现，挂起和回复线程的操作都需要转入<b>内核态</b>中完成，这些操作给系统打并发性带来了很大的压力。开发人员发现，其实共享数据的锁定状态只会持续很短一段时间，为了这段时间去挂起恢复线程不值得，所以我们让后面那个未获取到锁的对象自旋等待一下，不要放弃CPU执行时间。为了让线程等待，我们只需要在线程执行一个忙循环（自旋），这个就是自旋锁。

自旋锁在jdk1.6之后就默认开启了。自旋等待不能代替阻塞，在自旋等待的过程中会始终持续占据cpu资源，虽然避免了线程挂起恢复时间，但是cpu资源被占据了，导致了性能上的浪费。故自旋需要一个次数的限定，默认为10。

在jdk1.6之后引入了自适应的自旋锁。自适应意味着自旋的时间不再固定，由前一次再同一个锁上的自旋时间及锁的持有者的状态来决定。如果同一个锁的对象上，自旋等待刚成功获取到锁，并且持有锁的线程正在运行中，那么虚拟机会认为本次自旋获取锁也能够成功，会适当放宽其自旋时间。如果一个锁，自旋很少成功获取，那么之后的过程中可能直接省略自旋的过程，直接阻塞，避免浪费cpu资源。

### 锁消除

锁消除是指虚拟机即时编译期在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。即认定本线程拥有的堆上的所有数据都不会逃逸被其他线程访问到，那么可以把他们当作栈上的数据来对待，不需要加锁。

> todo：求大神，这里始终理解不进去，找不到例子

### 锁粗化

我们写代码的时候力求将锁的范围限制到最小，这样锁的范围最小，对系统影响最小。锁粗化与这个原则不同，指的是在一系列操作中都是对同一个对象反复的加锁解锁，甚至加锁的操作在循环体中，如此没有线程竞争，也会频繁进行互斥同步操作导致不必要的性能损耗。

> 比如在for中加锁，以及StringBuffer的append()方法

### 轻量级锁

轻量级锁是jdk1.6之后加入的新型锁机制，这里的“轻量级”是相对于操作系统中的互斥锁而言，所以传统的互斥锁被称为“重量级锁”。其被创造出来的本意是在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。

轻量级锁以及后续的偏向锁，都必须从对象头的内存布局开始介绍。HotSpot迅即的对象头分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（hashCode）、GC分代年龄（Generational GC Age）等，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit，官方称其为“Mark Word”，它是实现轻量级锁与偏向锁的关键。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。

对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，它会根据对象的状态服用自己的存储空间。例如，在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32bit空间中25bit用于存储对象的哈希码（HashCode），4bit用于存储对象分代年龄，2bit用于存储锁的标志位，1bit固定为0，在其他状态（轻量级锁定，重量级锁定，GC标记，可偏向）下对象的存储内容见下表

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码，对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空，不需要记录信息                   | 11     | GC标记             |
| 偏向线程ID，偏向时间戳，对象分代年龄 | 01     | 可偏向             |

加锁过程：

1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。
2. 拷贝对象头中的Mark Word复制到锁记录中。
3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。
4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。
5. 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

解锁过程：

1. 

### 偏向锁

在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取释放锁中，其实还没有锁的竞争，会造成很大加解锁与线程切换的开销

偏向锁，是为了消除数据在无竞争情况下的同步愿语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS都不做了。

> 简单理解，偏向锁就是同一个线程在没有其他线程竞争的时候获取锁，轻量级锁是在没有其他线程竞争的时候获取锁（但是可能每次获取锁都不是同一个线程），存在竞争的时候就膨胀成重量级锁



