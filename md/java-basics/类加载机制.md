# 类加载机制

## 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存位置，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证，准备，解析三个部分统称为连接（Linking），这7个阶段发生顺序如下图所示。

![https://raw.githubusercontent.com/Never12581/study-demo/master/other-file/picture/java-basics/%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png](https://raw.githubusercontent.com/Never12581/study-demo/master/other-file/picture/java-basics/类生命周期.png)

通常加载、验证、准备、初始化、卸载5个阶段的顺序是确定的，类在加载过程中必须按照这种顺序按部就班地开始，而解析阶段不一的当：它在某些情况下可以在初始化阶段之后开始。

有以下5种情况必须立即对类进行“初始化”（加载，验证，准备自然需要在此之前开始）：

1. 遇到new，getstataic，putstatic和invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发器初始化。生成这四条指令的常见的Java代码场景是：
   - new关键字
   - 读取或者设置一个类的静态字段
   - 调用一个类的静态方法
2. 使用java.lang.reflect包的方法对类进行发射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
3. 初始化一个类，发现其父类未初始化，则需要先触发父类的初始化
4. 执行主类（即包含main（）方法的类），虚拟机会优先初始化这个类
5. 当使用jdk 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

## 类加载的过程

### 加载

<font color='yellow'>“加载”是“类加载”过程的一个阶段！</font>

在加载阶段虚拟机要完成以下3件事情：

1. 通过一个全限定类名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

### 验证（待续）

验证主要包含以下四个方面（不具体日后补充）：

1. 文件格式验证

   验证字节流是否符合Class文件格式规范

2. 元数据验证

   验证是否符合当前Java语言规范。如：

   - 这个类是否有父类，除Object外均有父类
   - 是否继承了不被允许继承的类，如final修饰的类
   - 是否实现了父类或者接口中定义需实现的方法
   - 类字段、方法是否与父类矛盾

3. 字节码验证（待续）

4. 符号引用验证

### 准备

准备阶段是正式为类变量分配内存并设置变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有个两个容易产生混淆的概念需要强调一下，首先这时候进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量，实例变量将在对象实例化时随着对象一起被分配到堆内存中。其次，这里所说的初始值“通常情况下”是数据类型的零值，假设一个类变量的定义为：

```java
public static int value = 123;
```

那么变量在准备阶段之后，value的值是0而不是123

但是特殊情况如下

```java
public static final int value = 123;
```

这个在准备阶段value的值就是123

原因与字节码相关，待日后完善

### 解析

### 初始化

## 类加载器

### 类与类加载器

类加载器虽然只用于实现类的加载动作，但是它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：即比较两个类是否相同，只有在这两个类是在同一类加载器加载的前提下才有意义，两个类类加载器相同且类相同，才能证明两个类是同一个类（很拗口）

### 双亲委派模型

从虚拟机角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由C++实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由java实现，独立于虚拟机外部，且全部继承自java.lang.ClassLoader。

从功能上呢，则一般分为以下3种系统提供的类加载器：

- Bootstrap ClassLoader：这个类加载器负责将存放在<JAVA_HOME>\lib目录中的，或者呗制定-Xbootclasspath参数所制定的路径中，并且是虚拟机识别的（按照文件名识别，如rt.jar，如果不被识别则放入该目录下也不会被加载）类库加载到虚拟机内存中
- Extension ClassLoader：加载<JAVA_HOMT>\lib\ext中的类，或者java.ext.dirs系统变量所指定路径中所有类库。开发者可直接使用该类加载器
- Application ClassLoader：被称为系统类加载器，负责加载用户类路径上所指定的类。如果没有自定义类加载器，一般就是使用当前类作为程序默认类加载器

双亲委派模型要求除了顶层的类加载器外，其余的类加载器都应当有自己的父类加载器（此处非继承关系，一般使用组合关系复用父加载器代码）。

工作过程：如果一个类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有加载请求最终都应该传送到登层的启动类加载器中，只有父类反馈自己没法完成加载请求时，子加载器才会尝试自己去加载。

该模型保证了，我们可以重写与系统重名的类，可以编译却无法被加载运行。

### 破坏双亲委派模型

比如tomcat，启动时各个war包中的类肯定不能使用bootstrap classloader进行加载！











