# 类加载机制

## 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存位置，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证，准备，解析三个部分统称为连接（Linking），这7个阶段发生顺序如下图所示。

## 类加载的过程

## 类加载器

### 类与类加载器

类加载器虽然只用于实现类的加载动作，但是它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：即比较两个类是否相同，只有在这两个类是在同一类加载器加载的前提下才有意义，两个类类加载器相同且类相同，才能证明两个类是同一个类（很拗口）

### 双亲委派模型

从虚拟机角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由C++实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由java实现，独立于虚拟机外部，且全部继承自java.lang.ClassLoader。

从功能上呢，则一般分为以下3种系统提供的类加载器：

- Bootstrap ClassLoader：这个类加载器负责将存放在<JAVA_HOME>\lib目录中的，或者呗制定-Xbootclasspath参数所制定的路径中，并且是虚拟机识别的（按照文件名识别，如rt.jar，如果不被识别则放入该目录下也不会被加载）类库加载到虚拟机内存中
- Extension ClassLoader：加载<JAVA_HOMT>\lib\ext中的类，或者java.ext.dirs系统变量所指定路径中所有类库。开发者可直接使用该类加载器
- Application ClassLoader：被称为系统类加载器，负责加载用户类路径上所指定的类。如果没有自定义类加载器，一般就是使用当前类作为程序默认类加载器

双亲委派模型要求除了顶层的类加载器外，其余的类加载器都应当有自己的父类加载器（此处非继承关系，一般使用组合关系复用父加载器代码）。

工作过程：如果一个类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有加载请求最终都应该传送到登层的启动类加载器中，只有父类反馈自己没法完成加载请求时，子加载器才会尝试自己去加载。

该模型保证了，我们可以重写与系统重名的类，可以编译却无法被加载运行。

### 破坏双亲委派模型

比如tomcat，启动时各个war包中的类肯定不能使用bootstrap classloader进行加载！











