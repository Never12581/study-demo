# 垃圾收集器

## 记录GC案例

1. 出自占小狼博客

   在定义过多的类加载器的时候，会频繁出现FGC。

   > 原因：JVM内部为了实现高效分配，在类加载器第一次加载类的时候，会在Metaspace分配一个独立的内存块，随后该类加载加载的类信息都保存在该内存块。但如果这个类加载器只加载了一个类或者少数类，那这块内存就被浪费了，如果类加载器又特别多，那内存碎片就产生了。

## 如何判断对象已死

#### 引用计数算法（Reference Counting）

给对象添加一个引用计数器，每当有一个地方引用它，计数器的值+1；当引用失效的时候就-1；任何时候计数器为0的对象就是不可能再被引用的对象。

#### 可达性分析法（Reachability Analysis）

可达性分析法就是通过一系列被称为“GC root”的对象作为起始点，从这些节点向下搜索，搜索所走过的的路径称为引用链（Reference Chain），当一个对象到GC root没有任何引用链相连（即从GC Root出发该对象不可达）时，证明此对象不可用，被判定为可回收对象。

在java虚拟机中，可作为GC Root的对象包括以下几种：

- 虚拟机栈（栈帧中本地变量表）中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI（Native方法）引用的对象

#### 再谈引用

jdk1.2之后对引用进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）

-  强引用是指代码中普遍存在的如 Object o = new Object()，这类引用，只要强引用在，GC永远不会回收被引用的对象
- 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象列进回收范围之内进行第二次回收。回收之后还没有足够的内存，才抛出oom
- 弱引用也是用来描述非必需对象的，强度比软引用弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否存在虚引用对其生存时间完全没有影响，也无法通过虚引用获取一个对象实例。设置虚引用的唯一目的时在该对象被GC回收时会收到一个系统通知。

#### 生存还是死亡

在可达性分析中不可达的对象，会被标记并进行筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖该方法或者该方法已经被虚拟机执行了，这两种情况被虚拟机视为“没有必要执行”。

如果该对象被判定为有必要执行finalize()方法，则该对象会放置在一个叫做F-Quene对立中，并在稍后由虚拟机自动建立一个优先级低的Finalizer线程去执行它。执行指触发这个方法，并不会等待其结束（因为如果一个finalize方法执行死循环了，那么会导致F-Quene队列中的其他对象处于永久等待的情况）。

如果在finalize()方法中成功连上了GC Root对象，则可以不被回收

#### 回收方法区

方法区回收主要包括两部分内容：废弃常量和无用的类

废弃常量的回收与java堆中的回收非常相似。加入一个字符串“abc”已经进入了常量池中，但是当前系统中没有任何一个String对象引用常量池中“abc”这个常量，此时如果发生方法区回收，且有必要时，“abc”会被清理出常量池。

类的回收需要同时满足以下3点：

- 该类的所有实例已经被回收了
- 该类的classloader被回收了
- 本身的java.lang.Class对象没有任何地方引用，无法在任何地方通过反射访问该类的方法

满足以上3点则<font color='green'>可以</font>对类进行回收

这里说的是“可以”而非必然，HotSpot虚拟机提供以下几个命令对类是否回收进行控制

> -Xnoclassgc 控制是否会被回收
>
> -verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类的加载与卸载信息

方法区的回收是必要的，不然使用反射，动态代理，CGLib等框架频繁自定义ClassLoader的场景，需要虚拟机具备类等卸载功能。

## 垃圾收集算法

#### 标记清除算法

该算法分为两个阶段“标记”与“清除”两个阶段：

1. 标记出所有所需回收的对象
2. 回收被标记的对象

主要缺点：

1. 回收效率不高
2. 产生大量堆内存空间碎片

#### 复制算法

为解决“标记清除算法”效率问题，复制算法出现了。它将内存按容量划分为大小相等的两块，每次只使用一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把已使用的内存一次性清除掉

优点：

1. 不会出现内存碎片的情况
2. 清除速度快

缺点：

1. 将内存缩小为原先的一半

现在商业虚拟机都适用该算法来实现新生代的垃圾回收。将内存分为一块较大的Eden空间和两块较小的survivor空间，每次使用Eden和一块Survivor空间，每次回收时将存活的对象复制到另一块Survivor空间。

> 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，**在经过一次 Minor GC 后，如**
>
> **果对象还存活，并且能够被另外一块 Survivor 区域所容纳**( 上面已经假设为 from 区域，这里应为 to 区域，
>
> 即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，**则使用复制算法将这些仍然还存活的对**
>
> **象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中**，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即
>
> from 区域 )，**并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年**
>
> **龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定**
>
>  **)，这些对象就会成为老年代。**

#### 标记整理算法

标记的过程与“标记-清除”算法一致，后续的步骤是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。

一般用于老年代

#### 分代收集算法

该算法没有新思想，只是根据对象存活周期将内存划分为不同的几块。一般java堆分为新生代与老年代，新生代朝生夕死使用复制算法，老年代中对象存活时间长，使用标记-清除或者标记-整理算法。

## 垃圾收集器

#### CMS收集器

CMS（Concurrent Mark Swap）收集器是一种以最短回收停顿时间为目标的收集器。是<font color='green'>老年代</font>的收集器，与ParNew收集器一起工作。

CMS收集器是基于“<font color='blue'>标记-清除</font>”算法实现的，基本步骤如下：

- 初始标记（CMS inital mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

其中，初始标记、重新标记两个步骤仍然需要“stop the world”。初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快；并发标记阶段就是进行GC Roots Tracing的过程；重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中消耗时间最长的是并发标记和并发清除过程都可以与用户线程一起工作，所以，总体来说，CMS收集器的内存回收过程与用户线程一起并发执行。

CMS收集器有以下三个缺点：

- CMS收集器堆CPU资源非常敏感。当cpu核心数过低，cms收集器会占据过多cpu资源，也会降低系统吞吐量。
- CMS是一款基于“标记-清除”算法的收集器，所以会导致过多的碎片内存，无法分配大对象容易触发FULL GC。为解决这个问题CMS提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），在cms要进行FULL GC时开启内存碎片整理，但是对应的停顿时间增长。CMS提供了另一个参数-XX:CMSFullGCsBeforeCompaction,该参数用于设置执行多少次不压缩的FULL GC后来一次带压缩的FULL GC
- CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurent Mode Failure”失败而导致另一次FULL GC产生。由于CMS并发清理阶段用户线程还在工作，还会产生垃圾，这部分垃圾未被标记，CMS无法在当次处理掉这些垃圾，只能留在下一次处理。故CMS也需要留足空间在并发收集时程序运作使用

#### G1收集器

特征：

- 并行与并发：G1充分利用CPU，多核环境下的硬件优势，使用过个cpu来缩短stop the world的时间。
- 分代收集：与其他收集器一样，分代概念在G1中依然保留。且不需要与其他收集器配合就能独立管理整个GC堆。
- 空间整合：与CMS“标记-清除”算法不同，G1从整体看采用的是“<font color='blue'>标记-整理</font>”的算法，从局部看是采用“复制“算法实现的。两种算法都不会产生内存碎片，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而触发下一次GC
- 可预测停顿：这个G1相对于CMS的优势。降低停顿时间时两者共同的关注点，但G1在除了追求低停顿外，还建立可预测停顿时间模型，能让使用者明确制定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

G1之前的其他收集器收集的范围都是新生代或者老年代，而G1收集器收集范围覆盖新生代与老年代。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），保留新生代与老年代概念，但是新生代与老年代不再是物理隔离的，他们都是一部分Region的集合。

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也是Garbage-First名称的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽量可能高的收集效率。

在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remebered Set来避免全堆扫描的。G1中每个Region都会有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。这样在内存回收是，在GC根节点的枚举范围内加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

在不计算维护Remembered Set的操作，G1收集器的运作大致分为以下几个步骤：

- 初始标记（Inital Marking）
- 并发标记（Concurrent Marking）
- 最终标记（Final Marking）
- 筛选回收（Live Data Counting and Evacuation）

前几个步骤与CMS有很多相似之处。初始标记阶段仅仅是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新的值（即当前Region正在执行回收，不可以分配对象到这里），这阶段需要停顿线程，但耗时很短。并发标记阶段时从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户线程并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered   Set Logs的数据合并到Remembered Set中，这阶段需停顿线程，但是可并行执行。最后在筛选回收阶段 首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。





